package edu.macalester.mscs.characters;

import edu.macalester.mscs.utils.FileUtils;
import edu.macalester.mscs.utils.WordUtils;
import org.apache.commons.lang3.StringUtils;

import java.util.*;

/**
 * CharacterFinder provides lots of different utility for generating a list of characters from a text.
 * The basis of the algorithm is to find capitalized words that don't start sentences.
 *
 * It takes into its constructor a list of capitalized words that should be ignored and a list of
 * capitalized words that should not be unique (such as titles, ie. President in President Obama).
 * It also takes in a string of characters that should define a sentence start. These should normally
 * include a period, question mark, exclamation mark, and whatever form of double quote is used to
 * indicate the beginning of a dialogue sentence.
 *
 * The class has two underlying data structures: a counter and an instance of CharacterGroups.
 * The counter is used initially to accumulate capitalized words and phrases, and maintains a count
 * of each of their occurrences. A capitalized phrase is a sequence of capitalized words seperated by
 * only spaces and the words "of" and "the".
 *
 * The counter can be built up manually using increment word, or by using the countCapitalized method
 * which takes a list of strings representing lines in a text file and processes them automatically.
 * The two methods can be used in combination for precise control. The class similarly provides a
 * removeWords method to remove words that may be undesired.
 *
 * The class then provides a sequence of methods that return different sets of strings. These include
 * titled names (names generated by looking at words that come after general words), pluralized words
 * (one indication of surnames or non-name words), surnames (words that appear as the second word in
 * more than one pair of words), places (words that appear following "of" in a name), and lonely
 * words (words that do not appear in capitalized phrases). There is also a method that derives names
 * by finding word pairs that end in a word from a list of surnames, as well as a method that derives
 * first names from a list of names (it just takes the first word of each name).
 *
 * For further pruning the counter, there are methods removeWords, removeWordsBelowThreshold,
 * removePlaces, and removeTitles. The first two remove words from a specific subset of words, where
 * one requires the word to appear in the text less than a specified threshold of times. The latter
 * two remove redundant words that contain place names or titles which do not add descriptors. For
 * example, if both "President Barack Obama" and "Barack Obama" were present, removeTitles would
 * remove "President Barack Obama" because it is redundant give "Barack Obama".
 *
 * At this point, focus shifts to the second data structure, an instance of CharacterGroups. The
 * buildCharacterGroups method is used to construct the instance from the counter. This method takes
 * a set of nondescriptive strings that should not be grouped on. A user can then manually combine
 * groups using the various combineGroups methods.
 *
 * The groups can then be converted to String lists using the getNameList and getFirstNameList
 * methods. The former method takes in an (optional) list of names and returns a list of strings
 * representing the groups associated with those names, with the specified name first. If no list of
 * names is specified, all groups are returned. The latter method also takes a list of names, but
 * only returns significant single-word names from the various groups.
 *
 * @author Ari Weiland
 */
public class CharacterFinder {

    // Words that should be completely ignored
    public static final Set<String> IGNORED_WORDS = new HashSet<>(Arrays.asList(
            "My", "He", "His", "We", "Their", "Your", // pronouns  (It???)
            "This", "That", "There", // indirect pronouns
            "Who", "Why", // questions
            "Man", "Men", "With", "If", "And", "Will", "Half", "Free", "Watch",
            "Wolf", "Hall", "Kingdoms", "Watchmen", "Shepherd", // miscellaneous
            "House", "Houses", "Clan", "Lords", "Ladies", "Kings", "Dothraki", // GoT specific
            "Father", "Mother", "Uncle", "Aunt", "Brother", "Brothers", "Sons" // familial references
    ));

    // Words that are not unique, but may still be descriptive, expecially in combination
    public static final Set<String> GENERAL_WORDS = new HashSet<>(Arrays.asList(
            "The", // titular articles
            "Lord", "Lady", "King", "Queen", "Regent", "Steward", "Prince", "Princess", // royal titles
            "Ser", "Maester", "Captain", "Commander", "Magister", "Master", "Builder",
            "Septon", "Knight", // professional titles
            "Young", "Old", "Fat", // endearing titles
            "Khal", "Ko", // dothraki titles
            "High", "Great", "Grand", "First", "Second", // superlatives
            "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten", "Eleven", "Twelve", // numbers
            "Black", "Red", "Green", "Blue", // colors
            "Land", "Lands", "Sea", "Seas", "Island", "Isles", "City", "Cities", // geographics
            "Alley", "Gate", "Keep", "Market", "Tower", // landmarks
            "Flowers" // needed to distinguish Knight of Flowers and Jafer Flowers
    ));

    private final Set<String> ignoredWords;
    private final Set<String> generalWords;
    private final String punctuation;

    private Map<String, Integer> counter = new HashMap<>();
    private CharacterGroups characterGroups;

    public CharacterFinder(Set<String> ignoredWords, Set<String> generalWords, String punctuation) {
        this.ignoredWords = ignoredWords;
        this.generalWords = generalWords;
        this.punctuation = punctuation;
    }

    public Set<String> getIgnoredWords() {
        return ignoredWords;
    }

    public Set<String> getGeneralWords() {
        return generalWords;
    }

    public String getPunctuation() {
        return punctuation;
    }

    public void clear() {
        counter.clear();
        characterGroups = null;
    }

    public void countCapitalized(List<String> lines) {
        for (String line : lines) {
            List<String> parts = breakLine(line);
            StringBuilder phrase = null;
            String toAdd = null;
            // find capitals that don't start sentences
            for (int i = 0; i < parts.size(); i++) {
                String part = parts.get(i);
                if (i > 0 && !WordUtils.precedesSentenceStart(parts.get(i - 1), punctuation)) {
                    if (WordUtils.isCapitalized(part) && !ignoredWords.contains(part)) {
                        if (!generalWords.contains(part)) {
                            incrementName(part, 0);
                        }
                        if (phrase == null) {
                            phrase = new StringBuilder(part);
                        } else {
                            phrase.append(part);
                        }
                        toAdd = phrase.toString();
                    } else {
                        if (phrase != null) {
                            if (part.equals(" ") || part.equals("of") || part.equals("the")) {
                                phrase.append(part);
                            } else {
                                if (!generalWords.contains(toAdd)) {
                                    incrementName(toAdd, 1);
                                }
                                phrase = null;
                            }
                        }
                    }
                }
            }
            // go back and get sentence starters that we've already seen
            phrase = null;
            for (int i = 0; i < parts.size(); i++) {
                String part = parts.get(i);
                if (phrase != null || counter.containsKey(part) && (i == 0 || WordUtils.precedesSentenceStart(parts.get(i - 1), punctuation))) {
                    if (part.length() > 1 && WordUtils.isCapitalized(part) && !ignoredWords.contains(part)) {
                        if (!generalWords.contains(part)) {
                            incrementName(part, 0);
                        }
                        if (phrase == null) {
                            phrase = new StringBuilder(part);
                        } else {
                            phrase.append(part);
                        }
                        toAdd = phrase.toString();
                    } else {
                        if (phrase != null) {
                            if (part.equals(" ") || part.equals("of") || part.equals("the")) {
                                phrase.append(part);
                            } else {
                                if (!GENERAL_WORDS.contains(toAdd)) {
                                    incrementName(toAdd, 1);
                                }
                                phrase = null;
                            }
                        }
                    }
                }
            }
        }
    }

    public void incrementName(String string, int increment) {
        if (counter.containsKey(string)) {
            counter.put(string, counter.get(string) + increment);
        } else {
            counter.put(string, increment);
        }
    }

    public String stripTitle(String cap) {
        String[] split = cap.split(" ");
        if (generalWords.contains(split[0]) && WordUtils.isCapitalized(split[1])) {
            return cap.substring(cap.indexOf(" ") + 1);
        } else {
            return cap;
        }
    }

    /**
     * Returns a set of names that occur in a word triplet preceded by an ignored word
     * @return
     */
    public Set<String> getTitledNames() {
        Set<String> words = counter.keySet();
        Set<String> names = new HashSet<>();
        Set<String> partNames = new HashSet<>();
        for (String cap : words) {
            String[] split = cap.split(" ");
            String name = cap.substring(cap.indexOf(" ") + 1);
            if (split.length > 1 && generalWords.contains(split[0]) && WordUtils.isCapitalized(split[1]) && !generalWords.contains(split[1])) {
                if (split.length == 2 && (split[0].equals("Ko") || split[0].equals("Khal")) || split.length == 3) {
                    names.add(name);
                } else {
                    partNames.add(split[1]);
                }
            }
        }
        for (String name : partNames) {
            boolean isUnique = true;
            for (String cap : words) {
                String[] split = cap.split(" ");
                if (split.length == 2) {
                    // it's still unique if this is Title + Name
                    isUnique = isUnique && !name.equals(split[0]) && (generalWords.contains(split[0]) || !name.equals(split[1]));
                    if (!generalWords.contains(split[0]) && !generalWords.contains(split[1])
                            && (name.equals(split[0]) || name.equals(split[1]))) {
                        names.add(cap);
                    }
                } else if (split.length > 2) {
                    for (String s : split) {
                        isUnique = isUnique && !name.equals(s) && !name.equals(s + "s");
                    }
                }
            }
            if (isUnique) {
                names.add(name);
            }
        }
        return names;
    }

    /**
     * Returns words that are exist in words as both "xxxx" and "xxxxs" and at least once do not follow "the"
     * Ignores words found in ignored
     * @return
     */
    public Set<String> getPluralizedNames() {
        Set<String> words = counter.keySet();
        Set<String> pluralized = new HashSet<>();
        for (String cap : words) {
            String[] split = cap.split(" ");
            for (int i = 1; i < split.length; i++) {
                String s = split[i];
                if (!generalWords.contains(s) && !split[i-1].equalsIgnoreCase("the") && words.contains(s) && words.contains(s + "s")) {
                    pluralized.add(s);
                }
            }
        }
        return pluralized;
    }

    /**
     * Returns words that come second in multiple word pairs
     * @return
     */
    public Set<String> getSurnames() {
        Set<String> words = counter.keySet();
        Set<String> surnames = new HashSet<>();
        Set<String> once = new HashSet<>();
        for (String cap : words) {
            String name = stripTitle(cap);
            String[] split = name.split(" ");
            if (split.length == 2 && !generalWords.contains(split[0]) && !generalWords.contains(split[1])) {
                if (once.contains(split[1])) {
                    surnames.add(split[1]);
                } else {
                    once.add(split[1]);
                }
            }
        }
        return surnames;
    }

    /**
     * Returns a set of phrases that follow "of" or "of the"
     * @return
     */
    public Set<String> getPlaces() {
        Set<String> words = counter.keySet();
        Set<String> places = new HashSet<>();
        for (String cap : words) {
            if (cap.contains(" of ")) {
                String place = cap.substring(cap.indexOf(" of") + 4);
                if (place.startsWith("the")) {
                    place = place.substring(4);
                }
                places.add(place);
            }
        }
        return places;
    }

    /**
     * Returns a set of all words that are not compound or part of compound phrases
     * @return
     */
    public Set<String> getLonelyWords() {
        Set<String> words = counter.keySet();
        Set<String> lonely = new HashSet<>(words);
        for (String cap : words) {
            if (cap.contains(" ")) {
                lonely.remove(cap);
                for (String s : cap.split(" ")) {
                    lonely.remove(s);
                }
            }
        }
        return lonely;
    }

    /**
     * Returns word pairs from words whose second word is in surnames
     * Ignores pairs with the first word in generalWords
     * @param surnames
     * @return
     */
    public Set<String> getNamesBySurname(Collection<String> surnames) {
        Set<String> words = counter.keySet();
        Set<String> names = new HashSet<>();
        for (String cap : words) {
            String name = stripTitle(cap);
            String[] split = name.split(" ");
            if (split.length == 2 && !generalWords.contains(split[0]) && surnames.contains(split[1])) {
                if (words.contains(name)) {
                    names.add(name);
                } else {
                    names.add(cap);
                }
            }
        }
        return names;
    }

    /**
     * Returns a set of the first words in names, a collection of word pairings
     * @param names
     * @return
     */
    public Set<String> getFirstNames(Collection<String> names) {
        Set<String> firstNames = new HashSet<>();
        for (String cap : names) {
            String[] split = stripTitle(cap).split(" ");
            firstNames.add(split[0]);
        }
        return firstNames;
    }

    /**
     * Returns a new set that is the intersection of two sets, via the retainAll method
     * @param set1
     * @param set2
     * @param <T>
     * @return
     */
    public static <T> Set<T> intersectSets(Set<T> set1, Set<T> set2) {
        Set<T> intersection = new HashSet<>(set2);
        intersection.retainAll(set1);
        return intersection;
    }

    public void removePlaces() {
        Map<String, Integer> reducedCounter = new HashMap<>();
        for (String cap : counter.keySet()) {
            String noPlace = cap;
            // strip "of..." bits
            if (noPlace.contains(" of ")) {
                String temp = noPlace.substring(0, noPlace.indexOf(" of "));
                if (!GENERAL_WORDS.contains(temp)) {
                    noPlace = temp;
                }
            }
            if (!reducedCounter.containsKey(noPlace)) {
                reducedCounter.put(noPlace, 0);
            }
            reducedCounter.put(noPlace, reducedCounter.get(noPlace) + counter.get(cap));
        }
        counter = reducedCounter;
    }

    public void removeTitles() {
        Map<String, Integer> reducedCounter = new HashMap<>();
        for (String cap : counter.keySet()) {
            String noTitle = cap;
            for (int i = StringUtils.countMatches(noTitle, ' '); i > 1; i--) {
                noTitle = stripTitle(noTitle);
            }
            if (!reducedCounter.containsKey(noTitle)) {
                reducedCounter.put(noTitle, 0);
            }
            reducedCounter.put(noTitle, reducedCounter.get(noTitle) + counter.get(cap));
        }
        counter = reducedCounter;
    }

    public void removeWords(String... words) {
        removeWordsBelowThreshold(Arrays.asList(words), Integer.MAX_VALUE);
    }

    public void removeWords(Collection<String> words) {
        removeWordsBelowThreshold(words, Integer.MAX_VALUE);
    }

    public void removeWordsBelowThreshold(Collection<String> words, int threshold) {
        Map<String, Integer> reducedCounter = new HashMap<>();
        for (String cap : counter.keySet()) {
            if (!words.contains(cap) || counter.get(cap) >= threshold) {
                reducedCounter.put(cap, counter.get(cap));
            }
        }
        counter = reducedCounter;
    }

    public void buildCharacterGroups(Set<String> nondescriptors) {
        characterGroups = new CharacterGroups(counter, nondescriptors);
    }

    public void combineGroups(String... groups) {
        combineGroups(Arrays.asList(groups));
    }

    public void combineGroups(Collection<String> groups) {
        String first = groups.iterator().next();
        for (String s : groups) {
            characterGroups.combineGroups(first, s);
        }
    }

    public List<String> getNameList() {
//        Map<Set<String>, Integer> groupMap = characterGroups.getGroups();
//        List<Map.Entry<Set<String>, Integer>> groups = new ArrayList<>(groupMap.entrySet());
//        groups.sort(ENTRY_COMPARATOR);
//        List<String> lines = new ArrayList<>();
//        for (Map.Entry<Set<String>, Integer> group : groups) {
//            System.out.println(group.getValue() + "\t" + group.getKey());
//            StringBuilder line = new StringBuilder();
//            boolean first = true;
//            for (String name : group.getKey()) {
//                if (first) {
//                    first = false;
//                } else {
//                    line.append(",");
//                }
//                line.append(name);
//            }
//            lines.add(line.toString());
//        }
//        System.out.println();
//        System.out.println(groups.size());
//        System.out.println();
//        return lines;

        return getNameList(characterGroups.getPrimaryAliases());
    }

    public List<String> getNameList(Collection<String> names) {
        Map<List<String>, Integer> groupMap = new HashMap<>();
        for (String s : names) {
            if (characterGroups.isAlias(s)) {
                List<String> list = new ArrayList<>();
                list.add(s);
                list.addAll(characterGroups.getGroup(s));
                groupMap.put(list, characterGroups.getAliasCount(s));
            } else {
                System.out.println(s);
            }
        }

        List<Map.Entry<List<String>, Integer>> groups = new ArrayList<>(groupMap.entrySet());
        groups.sort(ENTRY_COMPARATOR);
        List<String> lines = new ArrayList<>();
        for (Map.Entry<List<String>, Integer> group : groups) {
            System.out.println(group.getValue() + "\t" + group.getKey());
            StringBuilder line = new StringBuilder();
            boolean first = true;
            for (String name : group.getKey()) {
                if (first) {
                    first = false;
                } else {
                    line.append(",");
                }
                line.append(name);
            }
            lines.add(line.toString());
        }
        System.out.println();
        System.out.println(groups.size());
        System.out.println();
        return lines;
    }

    public List<String> getFirstNameList(Collection<String> names) {
        Map<List<String>, Integer> groupMap = new HashMap<>();
        for (String name : names) {
            if (characterGroups.isAlias(name)) {
                List<String> list = new ArrayList<>();
                String[] split = stripTitle(name).split(" ");
                list.add(split[0]);
                Set<String> set = new HashSet<>();
                for (String s : characterGroups.getGroup(name)) {
                    split = stripTitle(s).split(" ");
                    if (!generalWords.contains(split[0])) {
                        set.add(split[0]);
                    }
                }
                list.addAll(set);
                groupMap.put(list, characterGroups.getAliasCount(name));
            } else {
                System.out.println(name);
            }
        }

        List<Map.Entry<List<String>, Integer>> groups = new ArrayList<>(groupMap.entrySet());
        groups.sort(ENTRY_COMPARATOR);
        List<String> lines = new ArrayList<>();
        for (Map.Entry<List<String>, Integer> group : groups) {
            System.out.println(group.getValue() + "\t" + group.getKey());
            StringBuilder line = new StringBuilder();
            boolean first = true;
            for (String name : group.getKey()) {
                if (first) {
                    first = false;
                } else {
                    line.append(",");
                }
                line.append(name);
            }
            lines.add(line.toString());
        }
        System.out.println();
        System.out.println(groups.size());
        System.out.println();
        return lines;
    }

    public void printCounter() {
        List<Map.Entry<String, Integer>> caps = new ArrayList<>(counter.entrySet());
        caps.sort(ENTRY_COMPARATOR);
        for (Map.Entry<String, Integer> cap : caps) {
            System.out.println(cap.getKey() + "\t" + cap.getValue());
        }
        System.out.println();
        System.out.println(counter.size());
    }

    public static void main(String[] args) {
        CharacterFinder finder = new CharacterFinder(IGNORED_WORDS, GENERAL_WORDS, ".?!�");
        finder.countCapitalized(FileUtils.readFile("src/main/resources/text/got.txt"));
        finder.incrementName("Jeor Mormont", 1); // gets wrecked
        finder.incrementName("Jeor", 0);
        finder.removeWords("Tully Stark"); // gets picked up accidentally

        Set<String> titledNames = finder.getTitledNames();
        Set<String> pluralizedNames = finder.getPluralizedNames();
        Set<String> surnames = finder.getSurnames();
        Set<String> names = finder.getNamesBySurname(surnames);
        names.addAll(titledNames);
        Set<String> places = finder.getPlaces();
        Set<String> lonely = finder.getLonelyWords();

//        System.out.println(titledNames);
//        System.out.println(pluralizedNames);
//        System.out.println(surnames);
//        System.out.println(names);
//        System.out.println(places);
//        System.out.println(lonely);
//        System.out.println();

        finder.removePlaces();
        finder.removeTitles();
        finder.removeWordsBelowThreshold(lonely, 10);

        finder.printCounter();

        Set<String> nondescriptors = new HashSet<>();
        nondescriptors.addAll(pluralizedNames);
        nondescriptors.addAll(WordUtils.getPlurals(pluralizedNames));
        nondescriptors.addAll(surnames);
        nondescriptors.addAll(WordUtils.getPlurals(surnames));
        nondescriptors.addAll(places);
        finder.buildCharacterGroups(nondescriptors);

        finder.combineGroups("Eddard", "Ned");
        finder.combineGroups("Bran", "Brandon Stark");
        finder.combineGroups("Robert", "Usurper");
        finder.combineGroups("Petyr", "Littlefinger", "Lord Baelish");
        finder.combineGroups("Daenerys", "Dany", "Khaleesi", "Princess of Dragonstone");
        finder.combineGroups("Joffrey", "Joff");
        finder.combineGroups("Samwell", "Sam", "Piggy", "Lord of Ham");
        finder.combineGroups("Sandor", "Hound");
        finder.combineGroups("Benjen", "Ben");
        finder.combineGroups("Jeor", "Old Bear", "Commander Mormont", "Lord Mormont");
        finder.combineGroups("Tomard", "Tom");
        finder.combineGroups("Jon Arryn", "Lord Arryn");
        finder.combineGroups("Catelyn", "Lady Stark");
        finder.combineGroups("Pycelle", "Grand Maester");
        finder.combineGroups("Walder", "Lord Frey", "Lord of the Crossing");
        finder.combineGroups("Robert Arryn", "Lord of the Eyrie");
        finder.combineGroups("Lysa", "Lady Arryn");
        finder.combineGroups("Maege", "Lady Mormont");
        finder.combineGroups("Greatjon", "Lord Umber");
        finder.combineGroups("Shella", "Lady Whent");
        finder.combineGroups("Drogo", "Great Rider");
        finder.combineGroups("Renly", "Lord of Storm");
        finder.combineGroups("Benjen", "First Ranger");
        finder.combineGroups("Marq", "Lord Piper");
        finder.combineGroups("Tywin", "Lord of Casterly Rock");
        finder.combineGroups("Horas", "Horror");
        finder.combineGroups("Jonos", "Lord Bracken");
        finder.combineGroups("Tytos Blackwood", "Lord Blackwood");
        finder.combineGroups("Hobber", "Slobber");
        finder.combineGroups("Karyl", "Lord Vance");
        finder.combineGroups("Roose", "Lord of the Dreadfort", "Lord Bolton");
        finder.combineGroups("Hoster", "Lord of Riverrun");
        finder.combineGroups("Loras", "Knight of Flowers", "Daisy");

        names.add("Varys");
        names.add("Bronn");
        names.add("Septa Mordane");
        names.add("Pycelle");
        names.add("Mirri Maz Duur");
        names.add("Hodor");
        names.add("Pyp");
        names.add("Syrio Forel");
        names.add("Grenn");
        names.add("Irri");
        names.add("Jhiqui");
        names.add("Qotho");
        names.add("Osha");
        names.add("Shagga");
        names.add("Doreah");
        names.add("Yoren");
        names.add("Halder");
        names.add("Lyanna");
        names.add("Jhogo");
        names.add("Mord");
        names.add("Gared");
        names.add("Marillion");
        names.add("Aggo");
        names.add("Alyn");
        names.add("Haggo");
        names.add("Chett");
        names.add("Cohollo");
        names.add("Timett");
        names.add("Mycah");
        names.add("Conn");
        names.add("Shae");
        names.add("Rakharo");
        names.add("Chiggen");
        names.add("Desmond");
        names.add("Jyck");
        names.add("Donal Noye");
        names.add("Masha Heddle");
        names.add("Quaro");
        names.add("Hullen");
        names.add("Harwin");
        names.add("Moreo Tumitis");
        names.add("Dareon");
        names.add("Rhaego");
        names.add("Cayn");
        names.add("High Septon");
        names.add("Morrec");
        names.add("Maegor");
        names.add("Mance Rayder");
        names.add("Hobb");
        names.add("Malleon");
        names.add("Helman Tallhart");
        names.add("Jafer Flowers");
        names.add("Cotter Pyke");
        names.add("Hugh");
        names.add("Lothor Brune");
        names.add("Howland Reed");
        names.add("Bryce Caron");
        names.add("Mychel Redfort");
        names.add("Florian");
        names.add("Quorin Halfhand");
        names.add("Endrew Tarth");
        names.add("Jaehaerys");
        names.add("Jalabhar Xho");
        names.add("Podrick Payne");

        names.remove("Yard");           // mistake
        names.remove("Valyrian");       // mistake
        names.remove("Ned Stark");      // as Eddard Stark
        names.remove("Jon Stark");      // as Jon Snow
        names.remove("Daenerys Stormborn"); // as Daenerys Targaryen
        names.remove("Catelyn Tully");  // as Catelyn Stark
        names.remove("Joff");           // as Joffrey Baratheon
        names.remove("Rider");          // as Drogo
        names.remove("Sam Tarly");      // as Samwell Tarly
        names.remove("Piggy");          // as Samwell Tarly
        names.remove("Rodrik Stark");   // unused
        names.remove("Ben Stark");      // as Benjen Stark
        names.remove("Ranger");         // as Benjen Stark
        names.remove("Theon Stark");    // as Theon Greyjoy
        names.remove("Brynden Blackfish");  // as Brynden Tully
        names.remove("Daisy");          // as Loras Tyrell
        names.remove("Aegon Targaryen");// unused, too problematic
        names.remove("Torrhen Stark");  // unused
        names.remove("Horror");         // as Horas
        names.remove("Slobber");        // as Hobber

        Set<String> firstNames = finder.getFirstNames(names);

        FileUtils.writeFile(finder.getNameList(), "src/main/resources/data/characters/ari-list-full.txt");
        FileUtils.writeFile(finder.getNameList(names), "src/main/resources/data/characters/ari-list-clean.txt");
        FileUtils.writeFile(finder.getNameList(firstNames), "src/main/resources/data/characters/ari-list-no-dup.txt");
        FileUtils.writeFile(finder.getFirstNameList(names), "src/main/resources/data/characters/ari-list-first.txt");

    }

    private static List<String> breakLine(String line) {
        List<String> pieces = new ArrayList<>();
        StringBuilder sb = null;
        boolean letters = true;
        for (int i = 0; i < line.length(); i++) {
            char c = line.charAt(i);
            if (Character.isAlphabetic(c)) {
                if (sb == null) {
                    sb = new StringBuilder();
                }
                if (letters) {
                    sb.append(c);
                } else {
                    pieces.add(sb.toString());
                    letters = true;
                    sb = new StringBuilder("" + c);
                }
            } else {
                if (sb != null) { // ignore leading punctuation
                    if (!letters) {
                        sb.append(c);
                    } else {
                        pieces.add(sb.toString());
                        letters = false;
                        sb = new StringBuilder("" + c);
                    }
                }
            }
        }
        if (sb != null) {
            pieces.add(sb.toString());
        }
        return pieces;
    }

    private static final Comparator<Map.Entry<?, Integer>> ENTRY_COMPARATOR = new Comparator<Map.Entry<?, Integer>>() {
        @Override
        public int compare(Map.Entry<?, Integer> o1, Map.Entry<?, Integer> o2) {
            return o2.getValue() - o1.getValue();
        }
    };

}
